//! resolv.conf lifecycle management for rootfs isolation.
//!
//! This module provides [`RootfsResolvConf`], an RAII guard that manages
//! the resolv.conf file within a rootfs directory. It backs up the existing
//! resolv.conf before setup and restores it on teardown, ensuring DNS
//! resolution works inside chroot environments.

use std::fs;
use std::sync::Arc;

use anyhow::Result;
use camino::{Utf8Path, Utf8PathBuf};
use rustix::fs::{self as rfs, CWD, Mode, OFlags};
use tracing::info;

use crate::config::ResolvConfConfig;
use crate::error::RsdebstrapError;
use crate::executor::{CommandExecutor, CommandSpec};
use crate::privilege::PrivilegeMethod;

/// Backup suffix appended to the original resolv.conf during setup.
const BACKUP_SUFFIX: &str = ".rsdebstrap-orig";

/// Generates resolv.conf content from explicit configuration.
pub(crate) fn generate_resolv_conf(config: &ResolvConfConfig) -> String {
    let mut lines = Vec::new();
    lines.push("# Generated by rsdebstrap".to_string());
    if !config.search.is_empty() {
        lines.push(format!("search {}", config.search.join(" ")));
    }
    for ns in &config.name_servers {
        lines.push(format!("nameserver {}", ns));
    }
    lines.join("\n") + "\n"
}

/// RAII guard for resolv.conf lifecycle within a rootfs.
///
/// Backs up the existing resolv.conf before writing new content, and restores
/// the original on teardown. The `Drop` implementation ensures cleanup even
/// on error paths.
///
/// The `host_resolv_conf` parameter allows injecting a test-specific path
/// instead of using the real `/etc/resolv.conf`.
pub struct RootfsResolvConf {
    rootfs: Utf8PathBuf,
    config: Option<ResolvConfConfig>,
    host_resolv_conf: Utf8PathBuf,
    executor: Arc<dyn CommandExecutor>,
    privilege: Option<PrivilegeMethod>,
    active: bool,
    dry_run: bool,
    torn_down: bool,
}

impl RootfsResolvConf {
    /// Creates a new `RootfsResolvConf` instance.
    ///
    /// If `config` is `None`, setup and teardown are no-ops.
    pub fn new(
        rootfs: &Utf8Path,
        config: Option<ResolvConfConfig>,
        host_resolv_conf: &Utf8Path,
        executor: Arc<dyn CommandExecutor>,
        privilege: Option<PrivilegeMethod>,
        dry_run: bool,
    ) -> Self {
        Self {
            rootfs: rootfs.to_owned(),
            config,
            host_resolv_conf: host_resolv_conf.to_owned(),
            executor,
            privilege,
            active: false,
            dry_run,
            torn_down: false,
        }
    }

    /// Path to the rootfs resolv.conf.
    fn resolv_conf_path(&self) -> Utf8PathBuf {
        self.rootfs.join("etc/resolv.conf")
    }

    /// Path to the backup of the original resolv.conf.
    fn backup_path(&self) -> Utf8PathBuf {
        let mut path = self.resolv_conf_path().into_string();
        path.push_str(BACKUP_SUFFIX);
        Utf8PathBuf::from(path)
    }

    /// Path to the rootfs /etc directory.
    fn etc_path(&self) -> Utf8PathBuf {
        self.rootfs.join("etc")
    }

    /// Executes a command and checks for success.
    fn execute_and_check(&self, spec: &CommandSpec) -> Result<()> {
        let result = self.executor.execute(spec)?;
        if !result.success() {
            let status = result
                .status
                .map(|s| s.to_string())
                .unwrap_or_else(|| "unknown".to_string());
            return Err(RsdebstrapError::execution(spec, status).into());
        }
        Ok(())
    }

    /// Sets up resolv.conf in the rootfs.
    ///
    /// 1. Validates that `<rootfs>/etc` exists and is not a symlink
    /// 2. Determines content (copy from host or generate)
    /// 3. Backs up existing resolv.conf
    /// 4. Writes new resolv.conf with mode 0o644
    ///
    /// On write failure, rolls back the backup rename.
    pub fn setup(&mut self) -> Result<()> {
        let Some(config) = &self.config else {
            return Ok(());
        };

        if self.dry_run {
            info!("would set up resolv.conf in {}", self.rootfs);
            return Ok(());
        }

        let etc = self.etc_path();

        // Validate /etc exists and is not a symlink (fd-based, avoids TOCTOU with symlink_metadata)
        // Note: A TOCTOU window remains between this fd-based check and subsequent
        // command execution via CommandExecutor, as external commands (mv, cp) operate
        // on path strings. This is inherent when using privilege escalation commands.
        let _etc_fd = rfs::openat(
            CWD,
            etc.as_str(),
            OFlags::NOFOLLOW | OFlags::DIRECTORY | OFlags::RDONLY | OFlags::CLOEXEC,
            Mode::empty(),
        )
        .map_err(|e| match e {
            rustix::io::Errno::LOOP | rustix::io::Errno::NOTDIR => {
                RsdebstrapError::Isolation(format!(
                    "{} is a symlink or not a directory, refusing to set up resolv.conf \
                    (possible symlink attack)",
                    etc
                ))
            }
            _ => RsdebstrapError::io(format!("failed to open {}", etc), std::io::Error::from(e)),
        })?;

        let resolv_path = self.resolv_conf_path();
        let backup_path = self.backup_path();

        // Check for leftover backup from a previous crash
        if backup_path.exists() {
            return Err(RsdebstrapError::Isolation(format!(
                "backup file {} already exists (possible leftover from a previous crash; \
                please restore or remove it manually)",
                backup_path
            ))
            .into());
        }

        // Back up existing resolv.conf (may be a regular file or a symlink)
        let had_original = resolv_path.symlink_metadata().is_ok();
        if had_original {
            let spec =
                CommandSpec::new("mv", vec![resolv_path.to_string(), backup_path.to_string()])
                    .with_privilege(self.privilege);
            self.execute_and_check(&spec)?;
        }

        // Write new resolv.conf
        let write_result = if config.copy {
            let spec = CommandSpec::new(
                "cp",
                vec![self.host_resolv_conf.to_string(), resolv_path.to_string()],
            )
            .with_privilege(self.privilege);
            self.execute_and_check(&spec)
        } else {
            let content = generate_resolv_conf(config);
            let temp = tempfile::NamedTempFile::new().map_err(|e| {
                RsdebstrapError::io(
                    "failed to create temporary file for resolv.conf".to_string(),
                    e,
                )
            })?;
            fs::write(temp.path(), &content).map_err(|e| {
                RsdebstrapError::io(
                    format!("failed to write temporary resolv.conf: {}", temp.path().display()),
                    e,
                )
            })?;
            let temp_path = temp.path().to_string_lossy().to_string();
            let spec = CommandSpec::new("cp", vec![temp_path, resolv_path.to_string()])
                .with_privilege(self.privilege);
            self.execute_and_check(&spec)
        };

        if let Err(write_err) = write_result {
            // Roll back: restore backup
            if had_original {
                let rollback_spec =
                    CommandSpec::new("mv", vec![backup_path.to_string(), resolv_path.to_string()])
                        .with_privilege(self.privilege);
                if let Err(rollback_err) = self.execute_and_check(&rollback_spec) {
                    tracing::error!(
                        "failed to roll back resolv.conf backup after write failure: {}",
                        rollback_err
                    );
                }
            }
            return Err(write_err);
        }

        // Set permissions to 0o644
        let chmod_spec =
            CommandSpec::new("chmod", vec!["644".to_string(), resolv_path.to_string()])
                .with_privilege(self.privilege);
        if let Err(e) = self.execute_and_check(&chmod_spec) {
            tracing::warn!("failed to set permissions on {}: {}", resolv_path, e);
        }

        info!("set up resolv.conf in {}", self.rootfs);
        self.active = true;
        Ok(())
    }

    /// Tears down resolv.conf, restoring the original if it was backed up.
    ///
    /// This method is idempotent after a successful teardown.
    pub fn teardown(&mut self) -> Result<()> {
        if !self.active || self.torn_down {
            return Ok(());
        }

        let resolv_path = self.resolv_conf_path();
        let backup_path = self.backup_path();

        // Remove the written resolv.conf
        let rm_spec = CommandSpec::new("rm", vec!["-f".to_string(), resolv_path.to_string()])
            .with_privilege(self.privilege);
        self.execute_and_check(&rm_spec)?;

        // Restore backup if it exists
        if backup_path.exists() {
            let spec =
                CommandSpec::new("mv", vec![backup_path.to_string(), resolv_path.to_string()])
                    .with_privilege(self.privilege);
            self.execute_and_check(&spec)?;
        }

        info!("restored resolv.conf in {}", self.rootfs);
        self.torn_down = true;
        Ok(())
    }
}

impl Drop for RootfsResolvConf {
    fn drop(&mut self) {
        if self.active
            && !self.torn_down
            && let Err(e) = self.teardown()
        {
            tracing::error!(
                "failed to restore resolv.conf during cleanup: {}. \
                Manual cleanup may be required: check {}/etc/resolv.conf and \
                {}/etc/resolv.conf{}",
                e,
                self.rootfs,
                self.rootfs,
                BACKUP_SUFFIX
            );
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::executor::{CommandSpec, ExecutionResult};
    use std::os::unix::process::ExitStatusExt;
    use std::process::ExitStatus;
    use std::sync::Mutex;

    #[derive(Debug, Clone)]
    struct RecordedCall {
        args: Vec<String>,
        privilege: Option<PrivilegeMethod>,
    }

    struct MockResolvConfExecutor {
        calls: Mutex<Vec<RecordedCall>>,
        fail_on_call: Option<usize>,
    }

    impl MockResolvConfExecutor {
        fn new() -> Self {
            Self {
                calls: Mutex::new(Vec::new()),
                fail_on_call: None,
            }
        }

        fn failing_on(call_index: usize) -> Self {
            Self {
                fail_on_call: Some(call_index),
                ..Self::new()
            }
        }

        fn calls(&self) -> Vec<RecordedCall> {
            self.calls.lock().unwrap().clone()
        }
    }

    impl CommandExecutor for MockResolvConfExecutor {
        fn execute(&self, spec: &CommandSpec) -> Result<ExecutionResult> {
            let mut calls = self.calls.lock().unwrap();
            let index = calls.len();
            let mut args = vec![spec.command.clone()];
            args.extend(spec.args.iter().cloned());
            calls.push(RecordedCall {
                args,
                privilege: spec.privilege,
            });
            drop(calls);

            if self.fail_on_call == Some(index) {
                Ok(ExecutionResult {
                    status: Some(ExitStatus::from_raw(1 << 8)),
                })
            } else {
                Ok(ExecutionResult {
                    status: Some(ExitStatus::from_raw(0)),
                })
            }
        }
    }

    fn create_rootfs_with_etc(dir: &std::path::Path) -> Utf8PathBuf {
        let rootfs = Utf8PathBuf::from_path_buf(dir.to_path_buf()).unwrap();
        fs::create_dir_all(rootfs.join("etc")).unwrap();
        rootfs
    }

    fn mock_executor() -> Arc<MockResolvConfExecutor> {
        Arc::new(MockResolvConfExecutor::new())
    }

    // =========================================================================
    // generate_resolv_conf tests
    // =========================================================================

    #[test]
    fn generate_nameservers_only() {
        let config = ResolvConfConfig {
            copy: false,
            name_servers: vec!["8.8.8.8".parse().unwrap(), "8.8.4.4".parse().unwrap()],
            search: vec![],
        };
        let content = generate_resolv_conf(&config);
        assert_eq!(content, "# Generated by rsdebstrap\nnameserver 8.8.8.8\nnameserver 8.8.4.4\n");
    }

    #[test]
    fn generate_nameservers_and_search() {
        let config = ResolvConfConfig {
            copy: false,
            name_servers: vec!["127.0.0.1".parse().unwrap()],
            search: vec!["example.com".to_string(), "corp.example.com".to_string()],
        };
        let content = generate_resolv_conf(&config);
        assert_eq!(
            content,
            "# Generated by rsdebstrap\nsearch example.com corp.example.com\nnameserver 127.0.0.1\n"
        );
    }

    #[test]
    fn generate_search_only() {
        let config = ResolvConfConfig {
            copy: false,
            name_servers: vec![],
            search: vec!["example.com".to_string()],
        };
        let content = generate_resolv_conf(&config);
        assert_eq!(content, "# Generated by rsdebstrap\nsearch example.com\n");
    }

    #[test]
    fn generate_ipv6_nameserver() {
        let config = ResolvConfConfig {
            copy: false,
            name_servers: vec!["::1".parse().unwrap()],
            search: vec![],
        };
        let content = generate_resolv_conf(&config);
        assert_eq!(content, "# Generated by rsdebstrap\nnameserver ::1\n");
    }

    // =========================================================================
    // setup / teardown tests
    // =========================================================================

    #[test]
    fn setup_with_none_config_is_noop() {
        let temp = tempfile::tempdir().unwrap();
        let rootfs = create_rootfs_with_etc(temp.path());
        let executor = mock_executor();
        let mut rc = RootfsResolvConf::new(
            &rootfs,
            None,
            Utf8Path::new("/etc/resolv.conf"),
            executor.clone(),
            None,
            false,
        );
        rc.setup().unwrap();
        assert!(!rc.active);
        assert_eq!(executor.calls().len(), 0);
        rc.teardown().unwrap();
    }

    #[test]
    fn setup_dry_run_does_not_touch_filesystem() {
        let executor = mock_executor();
        let mut rc = RootfsResolvConf::new(
            Utf8Path::new("/nonexistent/rootfs"),
            Some(ResolvConfConfig {
                copy: false,
                name_servers: vec!["8.8.8.8".parse().unwrap()],
                search: vec![],
            }),
            Utf8Path::new("/etc/resolv.conf"),
            executor.clone(),
            None,
            true,
        );
        rc.setup().unwrap();
        assert!(!rc.active);
        assert_eq!(executor.calls().len(), 0);
    }

    #[test]
    fn setup_copy_mode_issues_correct_commands() {
        let temp = tempfile::tempdir().unwrap();
        let rootfs = create_rootfs_with_etc(temp.path());

        let host_resolv = temp.path().join("host_resolv.conf");
        fs::write(&host_resolv, "nameserver 1.2.3.4\n").unwrap();
        let host_path = Utf8PathBuf::from_path_buf(host_resolv).unwrap();

        let config = ResolvConfConfig {
            copy: true,
            name_servers: vec![],
            search: vec![],
        };

        let executor = mock_executor();
        let mut rc =
            RootfsResolvConf::new(&rootfs, Some(config), &host_path, executor.clone(), None, false);
        rc.setup().unwrap();
        assert!(rc.active);

        let calls = executor.calls();
        assert_eq!(calls.len(), 2);
        // cp host→resolv
        assert_eq!(calls[0].args[0], "cp");
        assert_eq!(calls[0].args[1], host_path.as_str());
        assert_eq!(calls[0].args[2], rootfs.join("etc/resolv.conf").as_str());
        // chmod 644
        assert_eq!(calls[1].args[0], "chmod");
        assert_eq!(calls[1].args[1], "644");
        assert_eq!(calls[1].args[2], rootfs.join("etc/resolv.conf").as_str());
    }

    #[test]
    fn setup_generate_mode_issues_correct_commands() {
        let temp = tempfile::tempdir().unwrap();
        let rootfs = create_rootfs_with_etc(temp.path());

        let config = ResolvConfConfig {
            copy: false,
            name_servers: vec!["8.8.8.8".parse().unwrap()],
            search: vec!["example.com".to_string()],
        };

        let executor = mock_executor();
        let mut rc = RootfsResolvConf::new(
            &rootfs,
            Some(config),
            Utf8Path::new("/etc/resolv.conf"),
            executor.clone(),
            None,
            false,
        );
        rc.setup().unwrap();
        assert!(rc.active);

        let calls = executor.calls();
        assert_eq!(calls.len(), 2);
        // cp temp→resolv (temp file path is random)
        assert_eq!(calls[0].args[0], "cp");
        assert_eq!(calls[0].args[2], rootfs.join("etc/resolv.conf").as_str());
        // chmod 644
        assert_eq!(calls[1].args[0], "chmod");
        assert_eq!(calls[1].args[1], "644");
    }

    #[test]
    fn setup_backs_up_existing_resolv_conf() {
        let temp = tempfile::tempdir().unwrap();
        let rootfs = create_rootfs_with_etc(temp.path());
        fs::write(rootfs.join("etc/resolv.conf"), "original\n").unwrap();

        let config = ResolvConfConfig {
            copy: false,
            name_servers: vec!["8.8.8.8".parse().unwrap()],
            search: vec![],
        };

        let executor = mock_executor();
        let mut rc = RootfsResolvConf::new(
            &rootfs,
            Some(config),
            Utf8Path::new("/etc/resolv.conf"),
            executor.clone(),
            None,
            false,
        );
        rc.setup().unwrap();

        let calls = executor.calls();
        // mv backup, cp write, chmod
        assert_eq!(calls.len(), 3);
        assert_eq!(calls[0].args[0], "mv");
        assert_eq!(calls[0].args[1], rootfs.join("etc/resolv.conf").as_str());
        assert!(calls[0].args[2].contains(BACKUP_SUFFIX));
        assert_eq!(calls[1].args[0], "cp");
        assert_eq!(calls[2].args[0], "chmod");
    }

    #[test]
    fn setup_with_privilege_adds_privilege_to_commands() {
        let temp = tempfile::tempdir().unwrap();
        let rootfs = create_rootfs_with_etc(temp.path());

        let config = ResolvConfConfig {
            copy: false,
            name_servers: vec!["8.8.8.8".parse().unwrap()],
            search: vec![],
        };

        let executor = mock_executor();
        let mut rc = RootfsResolvConf::new(
            &rootfs,
            Some(config),
            Utf8Path::new("/etc/resolv.conf"),
            executor.clone(),
            Some(PrivilegeMethod::Sudo),
            false,
        );
        rc.setup().unwrap();

        let calls = executor.calls();
        for call in &calls {
            assert_eq!(
                call.privilege,
                Some(PrivilegeMethod::Sudo),
                "command {:?} should have sudo privilege",
                call.args[0]
            );
        }
    }

    #[test]
    fn teardown_issues_rm_command() {
        let temp = tempfile::tempdir().unwrap();
        let rootfs = create_rootfs_with_etc(temp.path());
        let resolv_path = rootfs.join("etc/resolv.conf");

        let config = ResolvConfConfig {
            copy: false,
            name_servers: vec!["8.8.8.8".parse().unwrap()],
            search: vec![],
        };

        let executor = mock_executor();
        let mut rc = RootfsResolvConf::new(
            &rootfs,
            Some(config),
            Utf8Path::new("/etc/resolv.conf"),
            executor.clone(),
            None,
            false,
        );
        rc.setup().unwrap();

        let setup_call_count = executor.calls().len();
        rc.teardown().unwrap();
        assert!(rc.torn_down);

        let calls = executor.calls();
        let teardown_calls = &calls[setup_call_count..];
        // Only rm -f (no backup exists since mock executor didn't actually mv)
        assert_eq!(teardown_calls.len(), 1);
        assert_eq!(teardown_calls[0].args[0], "rm");
        assert_eq!(teardown_calls[0].args[1], "-f");
        assert_eq!(teardown_calls[0].args[2], resolv_path.as_str());
    }

    #[test]
    fn teardown_restores_backup_when_exists() {
        let temp = tempfile::tempdir().unwrap();
        let rootfs = create_rootfs_with_etc(temp.path());
        let resolv_path = rootfs.join("etc/resolv.conf");
        let backup_path = Utf8PathBuf::from(format!("{}{}", resolv_path, BACKUP_SUFFIX));

        let config = ResolvConfConfig {
            copy: false,
            name_servers: vec!["8.8.8.8".parse().unwrap()],
            search: vec![],
        };

        let executor = mock_executor();
        let mut rc = RootfsResolvConf::new(
            &rootfs,
            Some(config),
            Utf8Path::new("/etc/resolv.conf"),
            executor.clone(),
            None,
            false,
        );
        rc.setup().unwrap();

        // Manually create backup file to simulate what `mv` would have done
        fs::write(&backup_path, "original\n").unwrap();

        let setup_call_count = executor.calls().len();
        rc.teardown().unwrap();

        let calls = executor.calls();
        let teardown_calls = &calls[setup_call_count..];
        // rm -f resolv_path, mv backup→resolv
        assert_eq!(teardown_calls.len(), 2);
        assert_eq!(teardown_calls[0].args[0], "rm");
        assert_eq!(teardown_calls[0].args[1], "-f");
        assert_eq!(teardown_calls[0].args[2], resolv_path.as_str());
        assert_eq!(teardown_calls[1].args[0], "mv");
        assert_eq!(teardown_calls[1].args[1], backup_path.as_str());
        assert_eq!(teardown_calls[1].args[2], resolv_path.as_str());
    }

    #[test]
    fn setup_write_failure_triggers_rollback() {
        let temp = tempfile::tempdir().unwrap();
        let rootfs = create_rootfs_with_etc(temp.path());
        fs::write(rootfs.join("etc/resolv.conf"), "original\n").unwrap();

        let config = ResolvConfConfig {
            copy: false,
            name_servers: vec!["8.8.8.8".parse().unwrap()],
            search: vec![],
        };

        // mv backup succeeds (index 0), cp write fails (index 1)
        let executor = Arc::new(MockResolvConfExecutor::failing_on(1));
        let mut rc = RootfsResolvConf::new(
            &rootfs,
            Some(config),
            Utf8Path::new("/etc/resolv.conf"),
            executor.clone(),
            None,
            false,
        );
        let err = rc.setup().unwrap_err();
        assert!(err.to_string().contains("command execution failed"));
        assert!(!rc.active);

        let calls = executor.calls();
        // mv backup, cp (fails), mv rollback
        assert_eq!(calls.len(), 3);
        assert_eq!(calls[0].args[0], "mv"); // backup
        assert_eq!(calls[1].args[0], "cp"); // write (failed)
        assert_eq!(calls[2].args[0], "mv"); // rollback
        // Rollback should restore: mv backup→resolv
        let backup_path = format!("{}{}", rootfs.join("etc/resolv.conf"), BACKUP_SUFFIX);
        assert_eq!(calls[2].args[1], backup_path);
        assert_eq!(calls[2].args[2], rootfs.join("etc/resolv.conf").as_str());
    }

    #[test]
    fn setup_write_failure_without_original_skips_rollback() {
        let temp = tempfile::tempdir().unwrap();
        let rootfs = create_rootfs_with_etc(temp.path());
        // No existing resolv.conf

        let config = ResolvConfConfig {
            copy: false,
            name_servers: vec!["8.8.8.8".parse().unwrap()],
            search: vec![],
        };

        // cp write fails (index 0, no backup mv since no original)
        let executor = Arc::new(MockResolvConfExecutor::failing_on(0));
        let mut rc = RootfsResolvConf::new(
            &rootfs,
            Some(config),
            Utf8Path::new("/etc/resolv.conf"),
            executor.clone(),
            None,
            false,
        );
        let err = rc.setup().unwrap_err();
        assert!(err.to_string().contains("command execution failed"));
        assert!(!rc.active);

        let calls = executor.calls();
        // Only cp (fails), no rollback
        assert_eq!(calls.len(), 1);
        assert_eq!(calls[0].args[0], "cp");
    }

    // =========================================================================
    // Validation tests (pre-executor, filesystem-based)
    // =========================================================================

    #[test]
    fn setup_errors_when_etc_missing() {
        let temp = tempfile::tempdir().unwrap();
        let rootfs = Utf8PathBuf::from_path_buf(temp.path().to_path_buf()).unwrap();
        // No /etc created

        let config = ResolvConfConfig {
            copy: false,
            name_servers: vec!["8.8.8.8".parse().unwrap()],
            search: vec![],
        };

        let executor = mock_executor();
        let mut rc = RootfsResolvConf::new(
            &rootfs,
            Some(config),
            Utf8Path::new("/etc/resolv.conf"),
            executor.clone(),
            None,
            false,
        );
        let err = rc.setup().unwrap_err();
        assert!(err.to_string().contains("I/O error"));
        assert_eq!(executor.calls().len(), 0);
    }

    #[test]
    fn setup_errors_when_etc_is_symlink() {
        let temp = tempfile::tempdir().unwrap();
        let rootfs = Utf8PathBuf::from_path_buf(temp.path().to_path_buf()).unwrap();

        let real_etc = rootfs.join("real_etc");
        fs::create_dir_all(&real_etc).unwrap();
        std::os::unix::fs::symlink(&real_etc, rootfs.join("etc")).unwrap();

        let config = ResolvConfConfig {
            copy: false,
            name_servers: vec!["8.8.8.8".parse().unwrap()],
            search: vec![],
        };

        let executor = mock_executor();
        let mut rc = RootfsResolvConf::new(
            &rootfs,
            Some(config),
            Utf8Path::new("/etc/resolv.conf"),
            executor.clone(),
            None,
            false,
        );
        let err = rc.setup().unwrap_err();
        assert!(err.to_string().contains("symlink"));
        assert_eq!(executor.calls().len(), 0);
    }

    #[test]
    fn setup_errors_when_backup_exists() {
        let temp = tempfile::tempdir().unwrap();
        let rootfs = create_rootfs_with_etc(temp.path());

        fs::write(rootfs.join(format!("etc/resolv.conf{}", BACKUP_SUFFIX)), "leftover").unwrap();

        let config = ResolvConfConfig {
            copy: false,
            name_servers: vec!["8.8.8.8".parse().unwrap()],
            search: vec![],
        };

        let executor = mock_executor();
        let mut rc = RootfsResolvConf::new(
            &rootfs,
            Some(config),
            Utf8Path::new("/etc/resolv.conf"),
            executor.clone(),
            None,
            false,
        );
        let err = rc.setup().unwrap_err();
        assert!(err.to_string().contains("already exists"));
        assert_eq!(executor.calls().len(), 0);
    }

    // =========================================================================
    // Lifecycle tests
    // =========================================================================

    #[test]
    fn drop_triggers_teardown() {
        let temp = tempfile::tempdir().unwrap();
        let rootfs = create_rootfs_with_etc(temp.path());

        let config = ResolvConfConfig {
            copy: false,
            name_servers: vec!["8.8.8.8".parse().unwrap()],
            search: vec![],
        };

        let executor = mock_executor();
        {
            let mut rc = RootfsResolvConf::new(
                &rootfs,
                Some(config),
                Utf8Path::new("/etc/resolv.conf"),
                executor.clone(),
                None,
                false,
            );
            rc.setup().unwrap();
            // Drop without calling teardown
        }

        let calls = executor.calls();
        // Should have setup calls + teardown rm call
        let last = calls.last().unwrap();
        assert_eq!(last.args[0], "rm");
    }

    #[test]
    fn teardown_is_idempotent() {
        let temp = tempfile::tempdir().unwrap();
        let rootfs = create_rootfs_with_etc(temp.path());

        let config = ResolvConfConfig {
            copy: false,
            name_servers: vec!["8.8.8.8".parse().unwrap()],
            search: vec![],
        };

        let executor = mock_executor();
        let mut rc = RootfsResolvConf::new(
            &rootfs,
            Some(config),
            Utf8Path::new("/etc/resolv.conf"),
            executor.clone(),
            None,
            false,
        );
        rc.setup().unwrap();
        let after_setup = executor.calls().len();
        rc.teardown().unwrap();
        let after_first_teardown = executor.calls().len();
        rc.teardown().unwrap(); // second call should be no-op
        assert_eq!(executor.calls().len(), after_first_teardown);
        assert!(after_first_teardown > after_setup);
    }
}
