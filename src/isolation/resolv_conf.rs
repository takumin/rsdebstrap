//! resolv.conf lifecycle management for rootfs isolation.
//!
//! This module provides [`RootfsResolvConf`], an RAII guard that manages
//! the resolv.conf file within a rootfs directory. It backs up the existing
//! resolv.conf before setup and restores it on teardown, ensuring DNS
//! resolution works inside chroot environments.

use std::fs;
use std::os::unix::fs::PermissionsExt;

use anyhow::Result;
use camino::{Utf8Path, Utf8PathBuf};
use tracing::info;

use crate::config::ResolvConfConfig;
use crate::error::RsdebstrapError;

/// Backup suffix appended to the original resolv.conf during setup.
const BACKUP_SUFFIX: &str = ".rsdebstrap-orig";

/// Generates resolv.conf content from explicit configuration.
fn generate_resolv_conf(config: &ResolvConfConfig) -> String {
    let mut lines = Vec::new();
    lines.push("# Generated by rsdebstrap".to_string());
    if !config.search.is_empty() {
        lines.push(format!("search {}", config.search.join(" ")));
    }
    for ns in &config.name_servers {
        lines.push(format!("nameserver {}", ns));
    }
    lines.join("\n") + "\n"
}

/// RAII guard for resolv.conf lifecycle within a rootfs.
///
/// Backs up the existing resolv.conf before writing new content, and restores
/// the original on teardown. The `Drop` implementation ensures cleanup even
/// on error paths.
///
/// The `host_resolv_conf` parameter allows injecting a test-specific path
/// instead of using the real `/etc/resolv.conf`.
pub struct RootfsResolvConf {
    rootfs: Utf8PathBuf,
    config: Option<ResolvConfConfig>,
    host_resolv_conf: Utf8PathBuf,
    active: bool,
    dry_run: bool,
    torn_down: bool,
}

impl RootfsResolvConf {
    /// Creates a new `RootfsResolvConf` instance.
    ///
    /// If `config` is `None`, setup and teardown are no-ops.
    pub fn new(
        rootfs: &Utf8Path,
        config: Option<ResolvConfConfig>,
        host_resolv_conf: &Utf8Path,
        dry_run: bool,
    ) -> Self {
        Self {
            rootfs: rootfs.to_owned(),
            config,
            host_resolv_conf: host_resolv_conf.to_owned(),
            active: false,
            dry_run,
            torn_down: false,
        }
    }

    /// Path to the rootfs resolv.conf.
    fn resolv_conf_path(&self) -> Utf8PathBuf {
        self.rootfs.join("etc/resolv.conf")
    }

    /// Path to the backup of the original resolv.conf.
    fn backup_path(&self) -> Utf8PathBuf {
        let mut path = self.resolv_conf_path().into_string();
        path.push_str(BACKUP_SUFFIX);
        Utf8PathBuf::from(path)
    }

    /// Path to the rootfs /etc directory.
    fn etc_path(&self) -> Utf8PathBuf {
        self.rootfs.join("etc")
    }

    /// Sets up resolv.conf in the rootfs.
    ///
    /// 1. Validates that `<rootfs>/etc` exists and is not a symlink
    /// 2. Determines content (copy from host or generate)
    /// 3. Backs up existing resolv.conf
    /// 4. Writes new resolv.conf with mode 0o644
    ///
    /// On write failure, rolls back the backup rename.
    pub fn setup(&mut self) -> Result<()> {
        let Some(config) = &self.config else {
            return Ok(());
        };

        if self.dry_run {
            info!("would set up resolv.conf in {}", self.rootfs);
            return Ok(());
        }

        let etc = self.etc_path();

        // Validate /etc exists and is not a symlink
        let etc_metadata = fs::symlink_metadata(&etc)
            .map_err(|e| RsdebstrapError::io(format!("failed to read metadata: {}", etc), e))?;
        if etc_metadata.file_type().is_symlink() {
            return Err(RsdebstrapError::Isolation(format!(
                "{} is a symlink, refusing to set up resolv.conf \
                (possible symlink attack)",
                etc
            ))
            .into());
        }
        if !etc_metadata.is_dir() {
            return Err(RsdebstrapError::Isolation(format!("{} is not a directory", etc)).into());
        }

        // Determine content
        let content = if config.copy {
            fs::read_to_string(&self.host_resolv_conf)
                .map_err(|e| RsdebstrapError::io(self.host_resolv_conf.to_string(), e))?
        } else {
            generate_resolv_conf(config)
        };

        let resolv_path = self.resolv_conf_path();
        let backup_path = self.backup_path();

        // Check for leftover backup from a previous crash
        if backup_path.exists() {
            return Err(RsdebstrapError::Isolation(format!(
                "backup file {} already exists (possible leftover from a previous crash; \
                please restore or remove it manually)",
                backup_path
            ))
            .into());
        }

        // Back up existing resolv.conf (may be a regular file or a symlink)
        let had_original = resolv_path.symlink_metadata().is_ok();
        if had_original {
            fs::rename(&resolv_path, &backup_path).map_err(|e| {
                RsdebstrapError::io(
                    format!("failed to back up {} to {}", resolv_path, backup_path),
                    e,
                )
            })?;
        }

        // Write new resolv.conf
        if let Err(write_err) = fs::write(&resolv_path, &content) {
            // Roll back: restore backup
            if had_original && let Err(rollback_err) = fs::rename(&backup_path, &resolv_path) {
                tracing::error!(
                    "failed to roll back resolv.conf backup after write failure: {}",
                    rollback_err
                );
            }
            return Err(
                RsdebstrapError::io(format!("failed to write {}", resolv_path), write_err).into()
            );
        }

        // Set permissions to 0o644
        if let Err(e) = fs::set_permissions(&resolv_path, fs::Permissions::from_mode(0o644)) {
            tracing::warn!("failed to set permissions on {}: {}", resolv_path, e);
        }

        info!("set up resolv.conf in {}", self.rootfs);
        self.active = true;
        Ok(())
    }

    /// Tears down resolv.conf, restoring the original if it was backed up.
    ///
    /// This method is idempotent after a successful teardown.
    pub fn teardown(&mut self) -> Result<()> {
        if !self.active || self.torn_down {
            return Ok(());
        }

        let resolv_path = self.resolv_conf_path();
        let backup_path = self.backup_path();

        // Remove the written resolv.conf
        if let Err(e) = fs::remove_file(&resolv_path)
            && e.kind() != std::io::ErrorKind::NotFound
        {
            return Err(RsdebstrapError::io(format!("failed to remove {}", resolv_path), e).into());
        }

        // Restore backup if it exists
        if backup_path.exists() {
            fs::rename(&backup_path, &resolv_path).map_err(|e| {
                RsdebstrapError::io(
                    format!("failed to restore {} from {}", resolv_path, backup_path),
                    e,
                )
            })?;
        }

        info!("restored resolv.conf in {}", self.rootfs);
        self.torn_down = true;
        Ok(())
    }
}

impl Drop for RootfsResolvConf {
    fn drop(&mut self) {
        if self.active
            && !self.torn_down
            && let Err(e) = self.teardown()
        {
            tracing::error!(
                "failed to restore resolv.conf during cleanup: {}. \
                Manual cleanup may be required: check {}/etc/resolv.conf and \
                {}/etc/resolv.conf{}",
                e,
                self.rootfs,
                self.rootfs,
                BACKUP_SUFFIX
            );
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn create_rootfs_with_etc(dir: &std::path::Path) -> Utf8PathBuf {
        let rootfs = Utf8PathBuf::from_path_buf(dir.to_path_buf()).unwrap();
        fs::create_dir_all(rootfs.join("etc")).unwrap();
        rootfs
    }

    // =========================================================================
    // generate_resolv_conf tests
    // =========================================================================

    #[test]
    fn generate_nameservers_only() {
        let config = ResolvConfConfig {
            copy: false,
            name_servers: vec!["8.8.8.8".parse().unwrap(), "8.8.4.4".parse().unwrap()],
            search: vec![],
        };
        let content = generate_resolv_conf(&config);
        assert_eq!(content, "# Generated by rsdebstrap\nnameserver 8.8.8.8\nnameserver 8.8.4.4\n");
    }

    #[test]
    fn generate_nameservers_and_search() {
        let config = ResolvConfConfig {
            copy: false,
            name_servers: vec!["127.0.0.1".parse().unwrap()],
            search: vec!["example.com".to_string(), "corp.example.com".to_string()],
        };
        let content = generate_resolv_conf(&config);
        assert_eq!(
            content,
            "# Generated by rsdebstrap\nsearch example.com corp.example.com\nnameserver 127.0.0.1\n"
        );
    }

    #[test]
    fn generate_search_only() {
        let config = ResolvConfConfig {
            copy: false,
            name_servers: vec![],
            search: vec!["example.com".to_string()],
        };
        let content = generate_resolv_conf(&config);
        assert_eq!(content, "# Generated by rsdebstrap\nsearch example.com\n");
    }

    #[test]
    fn generate_ipv6_nameserver() {
        let config = ResolvConfConfig {
            copy: false,
            name_servers: vec!["::1".parse().unwrap()],
            search: vec![],
        };
        let content = generate_resolv_conf(&config);
        assert_eq!(content, "# Generated by rsdebstrap\nnameserver ::1\n");
    }

    // =========================================================================
    // setup / teardown tests
    // =========================================================================

    #[test]
    fn setup_with_none_config_is_noop() {
        let temp = tempfile::tempdir().unwrap();
        let rootfs = create_rootfs_with_etc(temp.path());
        let mut rc = RootfsResolvConf::new(&rootfs, None, Utf8Path::new("/etc/resolv.conf"), false);
        rc.setup().unwrap();
        assert!(!rc.active);
        rc.teardown().unwrap();
    }

    #[test]
    fn setup_dry_run_does_not_touch_filesystem() {
        let mut rc = RootfsResolvConf::new(
            Utf8Path::new("/nonexistent/rootfs"),
            Some(ResolvConfConfig {
                copy: false,
                name_servers: vec!["8.8.8.8".parse().unwrap()],
                search: vec![],
            }),
            Utf8Path::new("/etc/resolv.conf"),
            true,
        );
        rc.setup().unwrap();
        assert!(!rc.active); // dry-run doesn't set active
    }

    #[test]
    fn setup_copy_mode() {
        let temp = tempfile::tempdir().unwrap();
        let rootfs = create_rootfs_with_etc(temp.path());

        // Create a fake host resolv.conf
        let host_resolv = temp.path().join("host_resolv.conf");
        fs::write(&host_resolv, "nameserver 1.2.3.4\n").unwrap();
        let host_path = Utf8PathBuf::from_path_buf(host_resolv).unwrap();

        let config = ResolvConfConfig {
            copy: true,
            name_servers: vec![],
            search: vec![],
        };

        let mut rc = RootfsResolvConf::new(&rootfs, Some(config), &host_path, false);
        rc.setup().unwrap();
        assert!(rc.active);

        let content = fs::read_to_string(rootfs.join("etc/resolv.conf")).unwrap();
        assert_eq!(content, "nameserver 1.2.3.4\n");

        rc.teardown().unwrap();
        assert!(rc.torn_down);
        // No original file, so resolv.conf should be removed
        assert!(!rootfs.join("etc/resolv.conf").exists());
    }

    #[test]
    fn setup_nameservers_mode() {
        let temp = tempfile::tempdir().unwrap();
        let rootfs = create_rootfs_with_etc(temp.path());

        let config = ResolvConfConfig {
            copy: false,
            name_servers: vec!["8.8.8.8".parse().unwrap()],
            search: vec!["example.com".to_string()],
        };

        let mut rc =
            RootfsResolvConf::new(&rootfs, Some(config), Utf8Path::new("/etc/resolv.conf"), false);
        rc.setup().unwrap();

        let content = fs::read_to_string(rootfs.join("etc/resolv.conf")).unwrap();
        assert_eq!(content, "# Generated by rsdebstrap\nsearch example.com\nnameserver 8.8.8.8\n");

        rc.teardown().unwrap();
    }

    #[test]
    fn setup_and_teardown_restores_original() {
        let temp = tempfile::tempdir().unwrap();
        let rootfs = create_rootfs_with_etc(temp.path());

        // Create an original resolv.conf
        fs::write(rootfs.join("etc/resolv.conf"), "original content\n").unwrap();

        let config = ResolvConfConfig {
            copy: false,
            name_servers: vec!["8.8.8.8".parse().unwrap()],
            search: vec![],
        };

        let mut rc =
            RootfsResolvConf::new(&rootfs, Some(config), Utf8Path::new("/etc/resolv.conf"), false);
        rc.setup().unwrap();

        // Verify new content
        let content = fs::read_to_string(rootfs.join("etc/resolv.conf")).unwrap();
        assert_eq!(content, "# Generated by rsdebstrap\nnameserver 8.8.8.8\n");
        // Backup should exist
        assert!(
            rootfs
                .join(format!("etc/resolv.conf{}", BACKUP_SUFFIX))
                .exists()
        );

        rc.teardown().unwrap();

        // Original should be restored
        let content = fs::read_to_string(rootfs.join("etc/resolv.conf")).unwrap();
        assert_eq!(content, "original content\n");
        // Backup should be removed
        assert!(
            !rootfs
                .join(format!("etc/resolv.conf{}", BACKUP_SUFFIX))
                .exists()
        );
    }

    #[test]
    fn setup_and_teardown_restores_symlink() {
        let temp = tempfile::tempdir().unwrap();
        let rootfs = create_rootfs_with_etc(temp.path());

        // Create a symlink as the original resolv.conf (common on systemd systems)
        let target_file = rootfs.join("etc/resolv.conf.real");
        fs::write(&target_file, "real content\n").unwrap();
        std::os::unix::fs::symlink("resolv.conf.real", rootfs.join("etc/resolv.conf")).unwrap();

        let config = ResolvConfConfig {
            copy: false,
            name_servers: vec!["1.1.1.1".parse().unwrap()],
            search: vec![],
        };

        let mut rc =
            RootfsResolvConf::new(&rootfs, Some(config), Utf8Path::new("/etc/resolv.conf"), false);
        rc.setup().unwrap();

        // New content should be a regular file
        let content = fs::read_to_string(rootfs.join("etc/resolv.conf")).unwrap();
        assert_eq!(content, "# Generated by rsdebstrap\nnameserver 1.1.1.1\n");

        rc.teardown().unwrap();

        // Symlink should be restored
        let metadata = fs::symlink_metadata(rootfs.join("etc/resolv.conf")).unwrap();
        assert!(metadata.file_type().is_symlink());
    }

    #[test]
    fn setup_errors_when_host_resolv_conf_missing() {
        let temp = tempfile::tempdir().unwrap();
        let rootfs = create_rootfs_with_etc(temp.path());

        let config = ResolvConfConfig {
            copy: true,
            name_servers: vec![],
            search: vec![],
        };

        let mut rc = RootfsResolvConf::new(
            &rootfs,
            Some(config),
            Utf8Path::new("/nonexistent/resolv.conf"),
            false,
        );
        let err = rc.setup().unwrap_err();
        assert!(err.to_string().contains("I/O error"));
    }

    #[test]
    fn setup_errors_when_etc_missing() {
        let temp = tempfile::tempdir().unwrap();
        let rootfs = Utf8PathBuf::from_path_buf(temp.path().to_path_buf()).unwrap();
        // No /etc created

        let config = ResolvConfConfig {
            copy: false,
            name_servers: vec!["8.8.8.8".parse().unwrap()],
            search: vec![],
        };

        let mut rc =
            RootfsResolvConf::new(&rootfs, Some(config), Utf8Path::new("/etc/resolv.conf"), false);
        let err = rc.setup().unwrap_err();
        assert!(err.to_string().contains("I/O error"));
    }

    #[test]
    fn setup_errors_when_etc_is_symlink() {
        let temp = tempfile::tempdir().unwrap();
        let rootfs = Utf8PathBuf::from_path_buf(temp.path().to_path_buf()).unwrap();

        // Create /etc as a symlink
        let real_etc = rootfs.join("real_etc");
        fs::create_dir_all(&real_etc).unwrap();
        std::os::unix::fs::symlink(&real_etc, rootfs.join("etc")).unwrap();

        let config = ResolvConfConfig {
            copy: false,
            name_servers: vec!["8.8.8.8".parse().unwrap()],
            search: vec![],
        };

        let mut rc =
            RootfsResolvConf::new(&rootfs, Some(config), Utf8Path::new("/etc/resolv.conf"), false);
        let err = rc.setup().unwrap_err();
        assert!(err.to_string().contains("symlink"));
    }

    #[test]
    fn setup_errors_when_backup_exists() {
        let temp = tempfile::tempdir().unwrap();
        let rootfs = create_rootfs_with_etc(temp.path());

        // Create a leftover backup
        fs::write(rootfs.join(format!("etc/resolv.conf{}", BACKUP_SUFFIX)), "leftover").unwrap();

        let config = ResolvConfConfig {
            copy: false,
            name_servers: vec!["8.8.8.8".parse().unwrap()],
            search: vec![],
        };

        let mut rc =
            RootfsResolvConf::new(&rootfs, Some(config), Utf8Path::new("/etc/resolv.conf"), false);
        let err = rc.setup().unwrap_err();
        assert!(err.to_string().contains("already exists"));
    }

    #[test]
    fn drop_triggers_teardown() {
        let temp = tempfile::tempdir().unwrap();
        let rootfs = create_rootfs_with_etc(temp.path());

        fs::write(rootfs.join("etc/resolv.conf"), "original\n").unwrap();

        let config = ResolvConfConfig {
            copy: false,
            name_servers: vec!["8.8.8.8".parse().unwrap()],
            search: vec![],
        };

        {
            let mut rc = RootfsResolvConf::new(
                &rootfs,
                Some(config),
                Utf8Path::new("/etc/resolv.conf"),
                false,
            );
            rc.setup().unwrap();
            // Drop without calling teardown
        }

        // Original should be restored by Drop
        let content = fs::read_to_string(rootfs.join("etc/resolv.conf")).unwrap();
        assert_eq!(content, "original\n");
    }

    #[test]
    fn teardown_is_idempotent() {
        let temp = tempfile::tempdir().unwrap();
        let rootfs = create_rootfs_with_etc(temp.path());

        let config = ResolvConfConfig {
            copy: false,
            name_servers: vec!["8.8.8.8".parse().unwrap()],
            search: vec![],
        };

        let mut rc =
            RootfsResolvConf::new(&rootfs, Some(config), Utf8Path::new("/etc/resolv.conf"), false);
        rc.setup().unwrap();
        rc.teardown().unwrap();
        rc.teardown().unwrap(); // second call should be no-op
    }
}
